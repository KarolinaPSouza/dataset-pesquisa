public class entry_6133609 { public static void main(String[] args) { A.main(args); } } class A { public static void main(String[] args) { Input input = new Input(); Output output = new Output(); int n = input.nextInt(); int m = input.nextInt(); int k = input.nextInt(); int[] a = new int[n]; for (int i = 0; i < n; i++) a[i] = input.nextInt(); int[] b = new int[m]; for (int i = 0; i < m; i++) b[i] = input.nextInt(); sort(a); sort(b); int i = 0; int count = 0; for (int e: b) { for (; i < a.length; i++) { if (e < a[i] - k) break; else if (e <= a[i] + k) { count++; i++; break; } } } output.append(count).appendNewLine(); output.flush(); } private static void sort(int[] array) { AVLTreeMap_int_int map = new AVLTreeMap_int_int(); for (int e: array) { AVLTreeMap_int_int.Entry entry = map.put(e); entry.set(entry.value() + 1); } int[] i = {0}; map.forEach((k, v) -> { for (; v > 0; v--) array[i[0]++] = k; }); } } class AVLTreeMap_int_int { private Entry root; private int size; public int size() { return size; } public void forEach(Function_void_int_int biConsumer) { forEach(root, biConsumer); } private void forEach(Entry entry, Function_void_int_int biConsumer) { if (entry != null) { forEach(entry.left, biConsumer); biConsumer.apply(entry.key, entry.value); forEach(entry.right, biConsumer); } } public Entry put(int k) { Entry result; if (size == 0) result = root = new Entry(k, null); else { Entry entry = root; Entry child; while (true) { if (k < entry.key) { if (entry.left == null) { result = entry.left = child = new Entry(k, entry); break; } else entry = entry.left; } else if (k > entry.key) { if (entry.right == null) { result = entry.right = child = new Entry(k, entry); break; } else entry = entry.right; } else return entry; } for (; entry != null; child = entry, entry = entry.parent) { if (entry.left == child) { if (entry.balanceFactor == 1) { if (child.balanceFactor == 1) rotateLL(entry, child); else rotateLR(entry, child, child.right); break; } else if (++entry.balanceFactor == 0) break; } else { if (entry.balanceFactor == -1) { if (child.balanceFactor == -1) rotateRR(entry, child); else rotateRL(entry, child, child.left); break; } else if (--entry.balanceFactor == 0) break; } } } size++; return result; } public Entry get(int k) { for (Entry entry = root; entry != null; ) { if (k < entry.key) entry = entry.left; else if (k > entry.key) entry = entry.right; else return entry; } return null; } public Entry first() { Entry first; for (first = root; first.left != null; first = first.left); return first; } public Entry last() { Entry last; for (last = root; last.right != null; last = last.right); return last; } public Entry ceiling(int k) { Entry ceiling; for (ceiling = root; ; ceiling = ceiling.right) { if (ceiling == null) return null; if (k <= ceiling.key) { if (k == ceiling.key) return ceiling; else break; } } for (Entry entry = ceiling.left; entry != null; ) { if (k < entry.key) { ceiling = entry; entry = entry.left; } else if (k > entry.key) entry = entry.right; else { ceiling = entry; break; } } return ceiling; } public Entry floor(int k) { Entry floor; for (floor = root; ; floor = floor.left) { if (floor == null) return null; if (k >= floor.key) { if (k == floor.key) return floor; else break; } } for (Entry entry = floor.right; entry != null; ) { if (k > entry.key) { floor = entry; entry = entry.right; } else if (k < entry.key) entry = entry.left; else { floor = entry; break; } } return floor; } public Entry higher(int k) { Entry higher; for (higher = root; ; higher = higher.right) { if (higher == null) return null; else if (k < higher.key) break; } for (Entry entry = higher.left; entry != null; ) { if (k < entry.key) { higher = entry; entry = entry.left; } else entry = entry.right; } return higher; } public Entry lower(int k) { Entry lower; for (lower = root; ; lower = lower.left) { if (lower == null) return null; else if (k > lower.key) break; } for (Entry entry = lower.right; entry != null; ) { if (k > entry.key) { lower = entry; entry = entry.right; } else entry = entry.left; } return lower; } private void remove(Entry entry) { size--; if (entry.left != null && entry.right != null) { Entry next = entry.right; if (next.left == null) { replaceAsChild(entry, next); setNullableRightChild(entry, next.right); setNonNullRightChild(next, entry); setNonNullLeftChild(next, entry.left); entry.left = null; } else { do next = next.left; while (next.left != null); Entry parent = next.parent; replaceAsChild(entry, next); setNonNullLeftChild(parent, entry); setNonNullLeftChild(next, entry.left); entry.left = null; Entry right = entry.right; setNullableRightChild(entry, next.right); setNonNullRightChild(next, right); } int balanceFactor = entry.balanceFactor; entry.balanceFactor = next.balanceFactor; next.balanceFactor = balanceFactor; } else if (entry == root) { if (size == 0) root = null; else { root = entry.left == null ? entry.right : entry.left; root.parent = null; } return; } Entry removed = entry; Entry child = entry; for (entry = entry.parent; entry != null; child = entry, entry = entry.parent) { if (entry.left == child) { if (entry.balanceFactor == -1) { child = entry.right; if (child.balanceFactor == -1) { rotateRR(entry, child); entry = child; } else if (child.balanceFactor == 0) { rotateRO(entry, child); break; } else { Entry grandchild = child.left; rotateRL(entry, child, grandchild); entry = grandchild; } } else if (entry.balanceFactor-- == 0) break; } else { if (entry.balanceFactor == 1) { child = entry.left; if (child.balanceFactor == 1) { rotateLL(entry, child); entry = child; } else if (child.balanceFactor == 0) { rotateLO(entry, child); break; } else { Entry grandchild = child.right; rotateLR(entry, child, grandchild); entry = grandchild; } } else if (entry.balanceFactor++ == 0) break; } } child = removed.left == null ? removed.right : removed.left; if (removed.parent.left == removed) removed.parent.left = child; else removed.parent.right = child; if (child != null) child.parent = removed.parent; } private void rotateLL(Entry entry, Entry child) { entry.balanceFactor = 0; child.balanceFactor = 0; replaceAsChild(entry, child); setNullableLeftChild(entry, child.right); setNonNullRightChild(child, entry); } private void rotateLO(Entry entry, Entry child) { entry.balanceFactor = 1; child.balanceFactor = -1; replaceAsChild(entry, child); setNonNullLeftChild(entry, child.right); setNonNullRightChild(child, entry); } private void rotateLR(Entry entry, Entry child, Entry grandchild) { if (grandchild.balanceFactor == -1) { entry.balanceFactor = 0; child.balanceFactor = 1; setNonNullLeftChild(entry, grandchild.right); setNullableRightChild(child, grandchild.left); } else if (grandchild.balanceFactor == 0) { entry.balanceFactor = 0; child.balanceFactor = 0; setNullableLeftChild(entry, grandchild.right); setNullableRightChild(child, grandchild.left); } else { entry.balanceFactor = -1; child.balanceFactor = 0; setNullableLeftChild(entry, grandchild.right); setNonNullRightChild(child, grandchild.left); } grandchild.balanceFactor = 0; replaceAsChild(entry, grandchild); setNonNullRightChild(grandchild, entry); setNonNullLeftChild(grandchild, child); } private void rotateRR(Entry entry, Entry child) { entry.balanceFactor = 0; child.balanceFactor = 0; replaceAsChild(entry, child); setNullableRightChild(entry, child.left); setNonNullLeftChild(child, entry); } private void rotateRO(Entry entry, Entry child) { entry.balanceFactor = -1; child.balanceFactor = 1; replaceAsChild(entry, child); setNonNullRightChild(entry, child.left); setNonNullLeftChild(child, entry); } private void rotateRL(Entry entry, Entry child, Entry grandchild) { if (grandchild.balanceFactor == -1) { entry.balanceFactor = 1; child.balanceFactor = 0; setNullableRightChild(entry, grandchild.left); setNonNullLeftChild(child, grandchild.right); } else if (grandchild.balanceFactor == 0) { entry.balanceFactor = 0; child.balanceFactor = 0; setNullableRightChild(entry, grandchild.left); setNullableLeftChild(child, grandchild.right); } else { entry.balanceFactor = 0; child.balanceFactor = -1; setNonNullRightChild(entry, grandchild.left); setNullableLeftChild(child, grandchild.right); } grandchild.balanceFactor = 0; replaceAsChild(entry, grandchild); setNonNullLeftChild(grandchild, entry); setNonNullRightChild(grandchild, child); } private void setNonNullLeftChild(Entry entry, Entry child) { entry.left = child; child.parent = entry; } private void setNonNullRightChild(Entry entry, Entry child) { entry.right = child; child.parent = entry; } private void setNullableLeftChild(Entry entry, Entry child) { entry.left = child; if (child != null) child.parent = entry; } private void setNullableRightChild(Entry entry, Entry child) { entry.right = child; if (child != null) child.parent = entry; } private void replaceAsChild(Entry oldEntry, Entry newEntry) { Entry parent = oldEntry.parent; if (parent == null) root = newEntry; else if (parent.left == oldEntry) parent.left = newEntry; else parent.right = newEntry; newEntry.parent = parent; } public class entry_6133609 { private final int key; private int value; private Entry parent; private Entry left; private Entry right; private int balanceFactor; private Entry(int key, Entry parent) { this.key = key; this.parent = parent; } public int key() { return key; } public int value() { return value; } public void set(int value) { this.value = value; } public void remove() { AVLTreeMap_int_int.this.remove(this); } } } interface Function_void_int_int { void apply(int arg1, int arg2); } class Input { private final byte[] buffer; private int pos; public Input() { try { buffer = new byte[System.in.available() + 1]; buffer[buffer.length - 1] = '\n'; System.in.read(buffer); } catch (Exception ex) { throw new RuntimeException(ex); } } public byte[] next(int n) { while (true) { byte b = buffer[pos++]; if (b != '\n' && b != '\r') { pos--; break; } } byte[] bytes = new byte[n]; System.arraycopy(buffer, pos, bytes, 0, n); pos += n; return bytes; } public byte[] next() { int from; while (true) { byte b = buffer[pos++]; if (b != ' ' && b != '\n' && b != '\r') { from = pos; break; } } byte[] bytes; while (true) { byte b = buffer[pos++]; if (b == ' ' || b == '\n') { bytes = new byte[pos - from]; break; } else if (b == '\r') { bytes = new byte[pos++ - from]; break; } } System.arraycopy(buffer, from - 1, bytes, 0, bytes.length); return bytes; } public byte[] nextLine() { int from = pos; byte[] bytes; while (true) { byte b = buffer[pos++]; if (b == '\n') { bytes = new byte[pos - from - 1]; break; } else if (b == '\r') { bytes = new byte[pos++ - from - 1]; break; } } System.arraycopy(buffer, from, bytes, 0, bytes.length); return bytes; } public byte nextChar() { while (true) { byte b = buffer[pos++]; if (b != ' ' && b != '\n' && b != '\r') return b; } } public int nextInt() { int n; boolean positive; while (true) { byte b = buffer[pos++]; if (b == '-') { positive = false; n = buffer[pos++] - '0'; break; } else if (b >= '0' && b <= '9') { positive = true; n = b - '0'; break; } } while (true) { byte b = buffer[pos++]; if (b >= '0' && b <= '9') n = n * 10 + b - '0'; else { if (b == '\r') pos++; return positive ? n : -n; } } } public long nextLong() { long n; boolean positive; while (true) { byte b = buffer[pos++]; if (b == '-') { positive = false; n = buffer[pos++] - '0'; break; } else if (b >= '0' && b <= '9') { positive = true; n = b - '0'; break; } } while (true) { byte b = buffer[pos++]; if (b >= '0' && b <= '9') n = n * 10 + b - '0'; else { if (b == '\r') pos++; return positive ? n : -n; } } } public double nextDouble() { long n; boolean positive; while (true) { byte b = buffer[pos++]; if (b == '-') { positive = false; n = buffer[pos++] - '0'; break; } else if (b >= '0' && b <= '9') { positive = true; n = b - '0'; break; } } while (true) { byte b = buffer[pos++]; if (b >= '0' && b <= '9') n = n * 10 + b - '0'; else if (b == '.') break; else return positive ? n : -n; } long m = 0; long o = 1; while (true) { byte b = buffer[pos++]; if (b >= '0' && b <= '9') { m = m * 10 + b - '0'; o *= 10; } else { if (b == '\r') pos++; double d = n + (double)m / o; return positive ? d : -d; } } } public int[] nextInts(int n) { int[] ints = new int[n]; for (int i = 0; i < n; i++) ints[i] = nextInt(); return ints; } public long[] nextLongs(int n) { long[] longs = new long[n]; for (int i = 0; i < n; i++) longs[i] = nextLong(); return longs; } } class Output { private static final int BUFFER_SIZE = 1048576; private static final boolean CRLF = System.lineSeparator().equals("\r\n"); private final byte[] buffer = new byte[BUFFER_SIZE]; private int pos; public Output append(String s) { int length = s.length(); ensureCapacity(length); for (int i = 0; i < length; i++) buffer[pos++] = (byte)s.charAt(i); return this; } public Output append(byte[] bytes) { if (BUFFER_SIZE - pos < bytes.length) { flush(); if (bytes.length > BUFFER_SIZE) { System.out.write(bytes, 0, bytes.length); return this; } } for (byte b: bytes) buffer[pos++] = b; return this; } public Output append(byte[] bytes, int from, int to) { int length = to - from; if (BUFFER_SIZE - pos < length) { flush(); if (length > BUFFER_SIZE) { System.out.write(bytes, from, length); return this; } } for (int i = from; i < to; i++) buffer[pos++] = bytes[i]; return this; } public Output append(byte b) { ensureCapacity(1); buffer[pos++] = b; return this; } public Output append(char c) { return append((byte)c); } public Output append(int i) { return append(Integer.toString(i)); } public Output append(long l) { return append(Long.toString(l)); } public Output append(double d) { return append(Double.toString(d)); } public void appendNewLine() { ensureCapacity(2); if (CRLF) buffer[pos++] = '\r'; buffer[pos++] = '\n'; } public void flush() { System.out.write(buffer, 0, pos); pos = 0; } private void ensureCapacity(int n) { if (BUFFER_SIZE - pos < n) flush(); } }