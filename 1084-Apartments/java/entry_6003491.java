public class entry_6003491 { public static void main(String[] args) { B.main(args); } } class B { public static void main(String[] args) { Input input = new Input(); Output output = new Output(); int n = input.nextInt(); int m = input.nextInt(); int k = input.nextInt(); int[] a = new int[n]; for (int i = 0; i < n; i++) a[i] = input.nextInt(); int[] b = new int[m]; for (int i = 0; i < m; i++) b[i] = input.nextInt(); RadixSort_int.sort(a); RadixSort_int.sort(b); int i = 0; int count = 0; for (int e: b) { for (; i < a.length; i++) { if (e < a[i] - k) break; else if (e <= a[i] + k) { count++; i++; break; } } } output.append(count).appendNewLine(); output.flush(); } } class Input { private final byte[] buffer; private int pos; public Input() { try { buffer = new byte[System.in.available() + 1]; buffer[buffer.length - 1] = '\n'; System.in.read(buffer); } catch (Exception ex) { throw new RuntimeException(ex); } } public byte[] next(int n) { while (true) { byte b = buffer[pos++]; if (b != '\n' && b != '\r') { pos--; break; } } byte[] bytes = new byte[n]; System.arraycopy(buffer, pos, bytes, 0, n); pos += n; return bytes; } public byte[] next() { int from; while (true) { byte b = buffer[pos++]; if (b != ' ' && b != '\n' && b != '\r') { from = pos; break; } } byte[] bytes; while (true) { byte b = buffer[pos++]; if (b == ' ' || b == '\n') { bytes = new byte[pos - from]; break; } else if (b == '\r') { bytes = new byte[pos++ - from]; break; } } System.arraycopy(buffer, from - 1, bytes, 0, bytes.length); return bytes; } public byte[] nextLine() { int from = pos; byte[] bytes; while (true) { byte b = buffer[pos++]; if (b == '\n') { bytes = new byte[pos - from - 1]; break; } else if (b == '\r') { bytes = new byte[pos++ - from - 1]; break; } } System.arraycopy(buffer, from, bytes, 0, bytes.length); return bytes; } public byte nextChar() { while (true) { byte b = buffer[pos++]; if (b != ' ' && b != '\n' && b != '\r') return b; } } public int nextInt() { int n; boolean positive; while (true) { byte b = buffer[pos++]; if (b == '-') { positive = false; n = buffer[pos++] - '0'; break; } else if (b >= '0' && b <= '9') { positive = true; n = b - '0'; break; } } while (true) { byte b = buffer[pos++]; if (b >= '0' && b <= '9') n = n * 10 + b - '0'; else { if (b == '\r') pos++; return positive ? n : -n; } } } public long nextLong() { long n; boolean positive; while (true) { byte b = buffer[pos++]; if (b == '-') { positive = false; n = buffer[pos++] - '0'; break; } else if (b >= '0' && b <= '9') { positive = true; n = b - '0'; break; } } while (true) { byte b = buffer[pos++]; if (b >= '0' && b <= '9') n = n * 10 + b - '0'; else { if (b == '\r') pos++; return positive ? n : -n; } } } public double nextDouble() { long n; boolean positive; while (true) { byte b = buffer[pos++]; if (b == '-') { positive = false; n = buffer[pos++] - '0'; break; } else if (b >= '0' && b <= '9') { positive = true; n = b - '0'; break; } } while (true) { byte b = buffer[pos++]; if (b >= '0' && b <= '9') n = n * 10 + b - '0'; else if (b == '.') break; else return positive ? n : -n; } long m = 0; long o = 1; while (true) { byte b = buffer[pos++]; if (b >= '0' && b <= '9') { m = m * 10 + b - '0'; o *= 10; } else { if (b == '\r') pos++; double d = n + (double)m / o; return positive ? d : -d; } } } public int[] nextInts(int n) { int[] ints = new int[n]; for (int i = 0; i < n; i++) ints[i] = nextInt(); return ints; } } class Output { private static final int BUFFER_SIZE = 1048576; private static final boolean CRLF = System.lineSeparator().equals("\r\n"); private final byte[] buffer = new byte[BUFFER_SIZE]; private int pos; public Output append(String s) { int length = s.length(); ensureCapacity(length); for (int i = 0; i < length; i++) buffer[pos++] = (byte)s.charAt(i); return this; } public Output append(byte[] bytes) { if (BUFFER_SIZE - pos < bytes.length) { flush(); if (bytes.length > BUFFER_SIZE) { System.out.write(bytes, 0, bytes.length); return this; } } for (byte b: bytes) buffer[pos++] = b; return this; } public Output append(byte[] bytes, int from, int to) { int length = to - from; if (BUFFER_SIZE - pos < length) { flush(); if (length > BUFFER_SIZE) { System.out.write(bytes, from, length); return this; } } for (int i = from; i < to; i++) buffer[pos++] = bytes[i]; return this; } public Output append(byte b) { ensureCapacity(1); buffer[pos++] = b; return this; } public Output append(char c) { return append((byte)c); } public Output append(int i) { return append(Integer.toString(i)); } public Output append(long l) { return append(Long.toString(l)); } public Output append(double d) { return append(Double.toString(d)); } public void appendNewLine() { ensureCapacity(2); if (CRLF) buffer[pos++] = '\r'; buffer[pos++] = '\n'; } public void flush() { System.out.write(buffer, 0, pos); pos = 0; } private void ensureCapacity(int n) { if (BUFFER_SIZE - pos < n) flush(); } } class RadixSort_int { private static final int BITS = 16; private static final int RADIX = 1 << BITS; private static final int DEFAULT_BUCKET_CAPACITY = 2; private RadixSort_int() {} public static void sort(int[] a) { sort(a, 0, a.length); } public static void sort(int[] a, int from, int to) { int[][] buckets = new int[RADIX][DEFAULT_BUCKET_CAPACITY]; int[] sizes = new int[RADIX]; for (int i = from; i < to; i++) add(buckets, sizes, (int)(a[i] & RADIX - 1), a[i]); int[][] newBuckets = new int[RADIX][DEFAULT_BUCKET_CAPACITY]; for (int i = BITS; i < Integer.SIZE; i += BITS) { int[] newSizes = new int[RADIX]; for (int j = 0; j < RADIX; j++) { for (int k = 0; k < sizes[j]; k++) add(newBuckets, newSizes, (int)(buckets[j][k] >>> i & RADIX - 1), buckets[j][k]); } int[][] temp = buckets; buckets = newBuckets; newBuckets = temp; sizes = newSizes; } { int i = 0; for (int j = RADIX >> 1; j < RADIX; j++) { for (int k = 0; k < sizes[j]; k++) a[i++] = buckets[j][k]; } for (int j = 0; j < RADIX >> 1; j++) { for (int k = 0; k < sizes[j]; k++) a[i++] = buckets[j][k]; } } } private static void add(int[][] buckets, int[] sizes, int index, int e) { int[] bucket = buckets[index]; int size = sizes[index]++; if (size == bucket.length) { int[] newBucket = new int[size << 1]; System.arraycopy(bucket, 0, newBucket, 0, size); bucket = buckets[index] = newBucket; } bucket[size] = e; } }