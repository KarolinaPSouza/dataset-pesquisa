// Generated by Code Flattener.
// https://plugins.jetbrains.com/plugin/9979-idea-code-flattener

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.Stack;
import java.util.StringTokenizer;
import java.util.logging.Level;
import java.util.logging.Logger;

public class entry_10143656 {
    public static void main(String[] args) {
        Solution obj = new Solution();
        obj.invoke();
    }

    private static class Solution {
        private final BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        private final static PrintWriter out = new PrintWriter(System.out);
        private final static Logger logger = Logger.getLogger(entry_10143656.class.getName());
        private StringTokenizer st = new StringTokenizer("");
        private boolean multiCase = false;

        public void invoke() {
            int t = 1;
            if (multiCase) t = nextInt();
            long startTime = System.nanoTime();
            while (t-- > 0) {
                solve();
            }
            long duration = (System.nanoTime() - startTime) / 1_000_000;
            out.flush();
            logger.log(Level.INFO, "Execution time: {0} ms", duration);
        }

        private void solve() {
            int n = nextInt();
            int m = nextInt();
            int[][] edges = new int[m][3];
            for (int i = 0; i < m; i++) {
                edges[i][0] = nextInt() - 1;
                edges[i][1] = nextInt() - 1;
                edges[i][2] = nextInt();
            }
            long[] dp = new long[n];
            int[] relaxant = new int[n];
            Arrays.fill(relaxant, -1);
            int cycleNode = -1;
            for (int i = 1; i <= n; i++) {
                cycleNode = -1;
                for (int[] edge : edges) {
                    int u = edge[0], v = edge[1], wt = edge[2];
                    if (dp[u] + wt < dp[v]) {
                        dp[v] = dp[u] + wt;
                        relaxant[v] = u;
                        cycleNode = v;
                    }
                }
            }
            if (cycleNode == -1) {
                println("NO");
                return;
            }
            for (int i = 1; i <= n; i++) {
                cycleNode = relaxant[cycleNode];
            }
            Stack<Integer> cycle = new Stack<Integer>();
            cycle.add(cycleNode);
            int node = relaxant[cycleNode];
            while (node != cycleNode) {
                cycle.push(node);
                node = relaxant[node];
            }
            cycle.add(node);
            println("YES");
            while (!cycle.isEmpty()) {
                print(cycle.pop() + 1);
            }
            println();
        }

        public String next() {
            while (!st.hasMoreTokens()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return st.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public void print(Object... str) {
            for (Object s : str)
                out.print(s + " ");
        }

        public void println(Object... str) {
            for (Object s : str)
                print(s + " ");
            out.println();
        }
    }
}