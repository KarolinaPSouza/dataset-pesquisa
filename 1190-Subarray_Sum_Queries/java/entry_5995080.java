public class entry_5995080 { public static void main(String[] args) { A.main(args); } } class A { public static void main(String[] args) { Input input = new Input(); Output output = new Output(); int n = input.nextInt(); int m = input.nextInt(); Element[] x = new Element[n]; for (int i = 0; i < n; i++) x[i] = new Element(input.nextInt()); SegmentTree_Element segmentTree = new SegmentTree_Element(x, new Element(0), (a, b) -> new Element(a.sum + b.sum, Math.max(a.right + b.left, Math.max(a.max, b.max)), Math.max(a.sum + b.left, a.left), Math.max(a.right + b.sum, b.right))); for (int i = 0; i < m; i++) { segmentTree.set(input.nextInt() - 1, new Element(input.nextInt())); output.append(segmentTree.get(0, n).max).appendNewLine(); } output.flush(); } } class Element { final long sum; final long max; final long left; final long right; public Element(int val) { sum = val; max = left = right = Math.max(val, 0); } public Element(long sum, long max, long left, long right) { this.sum = sum; this.max = max; this.left = left; this.right = right; } } interface Function_Element_Element_Element { Element apply(Element arg1, Element arg2); } class Input { private final byte[] buffer; private int pos; public Input() { try { buffer = new byte[System.in.available() + 1]; buffer[buffer.length - 1] = '\n'; System.in.read(buffer); } catch (Exception ex) { throw new RuntimeException(ex); } } public byte[] next(int n) { while (true) { byte b = buffer[pos++]; if (b != '\n' && b != '\r') { pos--; break; } } byte[] bytes = new byte[n]; System.arraycopy(buffer, pos, bytes, 0, n); pos += n; return bytes; } public byte[] next() { int from; while (true) { byte b = buffer[pos++]; if (b != ' ' && b != '\n' && b != '\r') { from = pos; break; } } byte[] bytes; while (true) { byte b = buffer[pos++]; if (b == ' ' || b == '\n') { bytes = new byte[pos - from]; break; } else if (b == '\r') { bytes = new byte[pos++ - from]; break; } } System.arraycopy(buffer, from - 1, bytes, 0, bytes.length); return bytes; } public byte[] nextLine() { int from = pos; byte[] bytes; while (true) { byte b = buffer[pos++]; if (b == '\n') { bytes = new byte[pos - from - 1]; break; } else if (b == '\r') { bytes = new byte[pos++ - from - 1]; break; } } System.arraycopy(buffer, from, bytes, 0, bytes.length); return bytes; } public byte nextChar() { while (true) { byte b = buffer[pos++]; if (b != ' ' && b != '\n' && b != '\r') return b; } } public int nextInt() { int n; boolean positive; while (true) { byte b = buffer[pos++]; if (b == '-') { positive = false; n = buffer[pos++] - '0'; break; } else if (b >= '0' && b <= '9') { positive = true; n = b - '0'; break; } } while (true) { byte b = buffer[pos++]; if (b >= '0' && b <= '9') n = n * 10 + b - '0'; else { if (b == '\r') pos++; return positive ? n : -n; } } } public long nextLong() { long n; boolean positive; while (true) { byte b = buffer[pos++]; if (b == '-') { positive = false; n = buffer[pos++] - '0'; break; } else if (b >= '0' && b <= '9') { positive = true; n = b - '0'; break; } } while (true) { byte b = buffer[pos++]; if (b >= '0' && b <= '9') n = n * 10 + b - '0'; else { if (b == '\r') pos++; return positive ? n : -n; } } } public double nextDouble() { long n; boolean positive; while (true) { byte b = buffer[pos++]; if (b == '-') { positive = false; n = buffer[pos++] - '0'; break; } else if (b >= '0' && b <= '9') { positive = true; n = b - '0'; break; } } while (true) { byte b = buffer[pos++]; if (b >= '0' && b <= '9') n = n * 10 + b - '0'; else if (b == '.') break; else return positive ? n : -n; } long m = 0; long o = 1; while (true) { byte b = buffer[pos++]; if (b >= '0' && b <= '9') { m = m * 10 + b - '0'; o *= 10; } else { if (b == '\r') pos++; double d = n + (double)m / o; return positive ? d : -d; } } } public int[] nextInts(int n) { int[] ints = new int[n]; for (int i = 0; i < n; i++) ints[i] = nextInt(); return ints; } } class Output { private static final int BUFFER_SIZE = 1048576; private static final boolean CRLF = System.lineSeparator().equals("\r\n"); private final byte[] buffer = new byte[BUFFER_SIZE]; private int pos; public Output append(String s) { int length = s.length(); ensureCapacity(length); for (int i = 0; i < length; i++) buffer[pos++] = (byte)s.charAt(i); return this; } public Output append(byte[] bytes) { if (BUFFER_SIZE - pos < bytes.length) { flush(); if (bytes.length > BUFFER_SIZE) { System.out.write(bytes, 0, bytes.length); return this; } } for (byte b: bytes) buffer[pos++] = b; return this; } public Output append(byte[] bytes, int from, int to) { int length = to - from; if (BUFFER_SIZE - pos < length) { flush(); if (length > BUFFER_SIZE) { System.out.write(bytes, from, length); return this; } } for (int i = from; i < to; i++) buffer[pos++] = bytes[i]; return this; } public Output append(byte b) { ensureCapacity(1); buffer[pos++] = b; return this; } public Output append(char c) { return append((byte)c); } public Output append(int i) { return append(Integer.toString(i)); } public Output append(long l) { return append(Long.toString(l)); } public Output append(double d) { return append(Double.toString(d)); } public void appendNewLine() { ensureCapacity(2); if (CRLF) buffer[pos++] = '\r'; buffer[pos++] = '\n'; } public void flush() { System.out.write(buffer, 0, pos); pos = 0; } private void ensureCapacity(int n) { if (BUFFER_SIZE - pos < n) flush(); } } class SegmentTree_Element { private final Element[] tree; private final Element defaultValue; private final Function_Element_Element_Element function; public SegmentTree_Element(Element[] elements, Element defaultValue, Function_Element_Element_Element function) { tree = new Element[elements.length << 1]; System.arraycopy(elements, 0, tree, elements.length, elements.length); for (int i = elements.length - 1; i > 0; i--) tree[i] = function.apply(tree[i << 1], tree[i << 1 | 1]); this.defaultValue = defaultValue; this.function = function; } public Element get(int from, int to) { Element resultLeft = defaultValue; Element resultRight = defaultValue; int offset = tree.length >> 1; for (from += offset, to += offset; from < to; from >>= 1, to >>= 1) { if ((from & 1) != 0) resultLeft = function.apply(resultLeft, tree[from++]); if ((to & 1) != 0) resultRight = function.apply(tree[--to], resultRight); } return function.apply(resultLeft, resultRight); } public Element get(int index) { return tree[index + (tree.length >> 1)]; } public void set(int index, Element value) { tree[index += tree.length >> 1] = value; for (; index != 1; index >>= 1) tree[index >> 1] = function.apply(tree[index & -2], tree[index | 1]); } }